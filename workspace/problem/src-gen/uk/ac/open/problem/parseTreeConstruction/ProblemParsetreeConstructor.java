/*
* generated by Xtext
*/
package uk.ac.open.problem.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import uk.ac.open.problem.services.ProblemGrammarAccess;


import com.google.inject.Inject;

public class ProblemParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private ProblemGrammarAccess grammarAccess;
		
	public ProblemGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProblemDiagram_Group(this, this, 0, inst);
			case 1: return new Node_Group(this, this, 1, inst);
			case 2: return new Phenomenon_Group(this, this, 2, inst);
			case 3: return new Link_Group(this, this, 3, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule ProblemDiagram ****************
 *
 * ProblemDiagram:
 *   ("problem" ":" description=STRING)? (nodes+=Node|links+=Link)*;
 *
 **/

// ("problem" ":" description=STRING)? (nodes+=Node|links+=Link)*
protected class ProblemDiagram_Group extends GroupToken {
	
	public ProblemDiagram_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getProblemDiagramAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProblemDiagram_Alternatives_1(parent, this, 0, inst);
			case 1: return new ProblemDiagram_Group_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getProblemDiagramRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ("problem" ":" description=STRING)?
protected class ProblemDiagram_Group_0 extends GroupToken {
	
	public ProblemDiagram_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getProblemDiagramAccess().getGroup_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProblemDiagram_DescriptionAssignment_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "problem"
protected class ProblemDiagram_ProblemKeyword_0_0 extends KeywordToken  {
	
	public ProblemDiagram_ProblemKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getProblemDiagramAccess().getProblemKeyword_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// ":"
protected class ProblemDiagram_ColonKeyword_0_1 extends KeywordToken  {
	
	public ProblemDiagram_ColonKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getProblemDiagramAccess().getColonKeyword_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProblemDiagram_ProblemKeyword_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// description=STRING
protected class ProblemDiagram_DescriptionAssignment_0_2 extends AssignmentToken  {
	
	public ProblemDiagram_DescriptionAssignment_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getProblemDiagramAccess().getDescriptionAssignment_0_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProblemDiagram_ColonKeyword_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("description",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("description");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getProblemDiagramAccess().getDescriptionSTRINGTerminalRuleCall_0_2_0();
			return obj;
		}
		return null;
	}

}


// (nodes+=Node|links+=Link)*
protected class ProblemDiagram_Alternatives_1 extends AlternativesToken {

	public ProblemDiagram_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getProblemDiagramAccess().getAlternatives_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProblemDiagram_NodesAssignment_1_0(parent, this, 0, inst);
			case 1: return new ProblemDiagram_LinksAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// nodes+=Node
protected class ProblemDiagram_NodesAssignment_1_0 extends AssignmentToken  {
	
	public ProblemDiagram_NodesAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getProblemDiagramAccess().getNodesAssignment_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("nodes",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nodes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getProblemDiagramAccess().getNodesNodeParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ProblemDiagram_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ProblemDiagram_Group_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// links+=Link
protected class ProblemDiagram_LinksAssignment_1_1 extends AssignmentToken  {
	
	public ProblemDiagram_LinksAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getProblemDiagramAccess().getLinksAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("links",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("links");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLinkRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getProblemDiagramAccess().getLinksLinkParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ProblemDiagram_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ProblemDiagram_Group_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}



/************ end Rule ProblemDiagram ****************/


/************ begin Rule Node ****************
 *
 * Node:
 *   name=ID type=NodeType? (":" description=STRING)? ("{" (subproblem=ProblemDiagram|
 *   "see" "domain" problemRef=[Node]|istar=Model|"see" "intention" istarRef=[
 *   openome_model::Intention]|hiddenPhenomena+=Phenomenon ("," hiddenPhenomena+=
 *   Phenomenon)*) "}")?;
 *
 **/

// name=ID type=NodeType? (":" description=STRING)? ("{" (subproblem=ProblemDiagram|
// "see" "domain" problemRef=[Node]|istar=Model|"see" "intention" istarRef=[
// openome_model::Intention]|hiddenPhenomena+=Phenomenon ("," hiddenPhenomena+=
// Phenomenon)*) "}")?
protected class Node_Group extends GroupToken {
	
	public Node_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Group_3(parent, this, 0, inst);
			case 1: return new Node_Group_2(parent, this, 1, inst);
			case 2: return new Node_TypeAssignment_1(parent, this, 2, inst);
			case 3: return new Node_NameAssignment_0(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class Node_NameAssignment_0 extends AssignmentToken  {
	
	public Node_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getNameAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getNodeAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// type=NodeType?
protected class Node_TypeAssignment_1 extends AssignmentToken  {
	
	public Node_TypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getTypeAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getNodeAccess().getTypeNodeTypeEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// (":" description=STRING)?
protected class Node_Group_2 extends GroupToken {
	
	public Node_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_DescriptionAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Node_ColonKeyword_2_0 extends KeywordToken  {
	
	public Node_ColonKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getColonKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_TypeAssignment_1(parent, this, 0, inst);
			case 1: return new Node_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// description=STRING
protected class Node_DescriptionAssignment_2_1 extends AssignmentToken  {
	
	public Node_DescriptionAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getDescriptionAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_ColonKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("description",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("description");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getNodeAccess().getDescriptionSTRINGTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}


// ("{" (subproblem=ProblemDiagram|"see" "domain" problemRef=[Node]|istar=Model|"see"
// "intention" istarRef=[openome_model::Intention]|hiddenPhenomena+=Phenomenon (","
// hiddenPhenomena+=Phenomenon)*) "}")?
protected class Node_Group_3 extends GroupToken {
	
	public Node_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_RightCurlyBracketKeyword_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class Node_LeftCurlyBracketKeyword_3_0 extends KeywordToken  {
	
	public Node_LeftCurlyBracketKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getLeftCurlyBracketKeyword_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Group_2(parent, this, 0, inst);
			case 1: return new Node_TypeAssignment_1(parent, this, 1, inst);
			case 2: return new Node_NameAssignment_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// subproblem=ProblemDiagram|"see" "domain" problemRef=[Node]|istar=Model|"see"
// "intention" istarRef=[openome_model::Intention]|hiddenPhenomena+=Phenomenon (","
// hiddenPhenomena+=Phenomenon)*
protected class Node_Alternatives_3_1 extends AlternativesToken {

	public Node_Alternatives_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getNodeAccess().getAlternatives_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_SubproblemAssignment_3_1_0(parent, this, 0, inst);
			case 1: return new Node_Group_3_1_1(parent, this, 1, inst);
			case 2: return new Node_IstarAssignment_3_1_2(parent, this, 2, inst);
			case 3: return new Node_Group_3_1_3(parent, this, 3, inst);
			case 4: return new Node_Group_3_1_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
}

// subproblem=ProblemDiagram
protected class Node_SubproblemAssignment_3_1_0 extends AssignmentToken  {
	
	public Node_SubproblemAssignment_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getSubproblemAssignment_3_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProblemDiagram_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subproblem",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subproblem");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getProblemDiagramRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNodeAccess().getSubproblemProblemDiagramParserRuleCall_3_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Node_LeftCurlyBracketKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "see" "domain" problemRef=[Node]
protected class Node_Group_3_1_1 extends GroupToken {
	
	public Node_Group_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup_3_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_ProblemRefAssignment_3_1_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "see"
protected class Node_SeeKeyword_3_1_1_0 extends KeywordToken  {
	
	public Node_SeeKeyword_3_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getSeeKeyword_3_1_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_LeftCurlyBracketKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "domain"
protected class Node_DomainKeyword_3_1_1_1 extends KeywordToken  {
	
	public Node_DomainKeyword_3_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getDomainKeyword_3_1_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_SeeKeyword_3_1_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// problemRef=[Node]
protected class Node_ProblemRefAssignment_3_1_1_2 extends AssignmentToken  {
	
	public Node_ProblemRefAssignment_3_1_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getProblemRefAssignment_3_1_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_DomainKeyword_3_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("problemRef",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("problemRef");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeAccess().getProblemRefNodeCrossReference_3_1_1_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getNodeAccess().getProblemRefNodeCrossReference_3_1_1_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


// istar=Model
protected class Node_IstarAssignment_3_1_2 extends AssignmentToken  {
	
	public Node_IstarAssignment_3_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getIstarAssignment_3_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("istar",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("istar");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getModelRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNodeAccess().getIstarModelParserRuleCall_3_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Node_LeftCurlyBracketKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "see" "intention" istarRef=[openome_model::Intention]
protected class Node_Group_3_1_3 extends GroupToken {
	
	public Node_Group_3_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup_3_1_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_IstarRefAssignment_3_1_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "see"
protected class Node_SeeKeyword_3_1_3_0 extends KeywordToken  {
	
	public Node_SeeKeyword_3_1_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getSeeKeyword_3_1_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_LeftCurlyBracketKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "intention"
protected class Node_IntentionKeyword_3_1_3_1 extends KeywordToken  {
	
	public Node_IntentionKeyword_3_1_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getIntentionKeyword_3_1_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_SeeKeyword_3_1_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// istarRef=[openome_model::Intention]
protected class Node_IstarRefAssignment_3_1_3_2 extends AssignmentToken  {
	
	public Node_IstarRefAssignment_3_1_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getIstarRefAssignment_3_1_3_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_IntentionKeyword_3_1_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("istarRef",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("istarRef");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeAccess().getIstarRefIntentionCrossReference_3_1_3_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getNodeAccess().getIstarRefIntentionCrossReference_3_1_3_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


// hiddenPhenomena+=Phenomenon ("," hiddenPhenomena+=Phenomenon)*
protected class Node_Group_3_1_4 extends GroupToken {
	
	public Node_Group_3_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup_3_1_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Group_3_1_4_1(parent, this, 0, inst);
			case 1: return new Node_HiddenPhenomenaAssignment_3_1_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// hiddenPhenomena+=Phenomenon
protected class Node_HiddenPhenomenaAssignment_3_1_4_0 extends AssignmentToken  {
	
	public Node_HiddenPhenomenaAssignment_3_1_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getHiddenPhenomenaAssignment_3_1_4_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Phenomenon_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hiddenPhenomena",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenPhenomena");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPhenomenonRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNodeAccess().getHiddenPhenomenaPhenomenonParserRuleCall_3_1_4_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Node_LeftCurlyBracketKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," hiddenPhenomena+=Phenomenon)*
protected class Node_Group_3_1_4_1 extends GroupToken {
	
	public Node_Group_3_1_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup_3_1_4_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_HiddenPhenomenaAssignment_3_1_4_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Node_CommaKeyword_3_1_4_1_0 extends KeywordToken  {
	
	public Node_CommaKeyword_3_1_4_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getCommaKeyword_3_1_4_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Group_3_1_4_1(parent, this, 0, inst);
			case 1: return new Node_HiddenPhenomenaAssignment_3_1_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// hiddenPhenomena+=Phenomenon
protected class Node_HiddenPhenomenaAssignment_3_1_4_1_1 extends AssignmentToken  {
	
	public Node_HiddenPhenomenaAssignment_3_1_4_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getHiddenPhenomenaAssignment_3_1_4_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Phenomenon_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hiddenPhenomena",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenPhenomena");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPhenomenonRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNodeAccess().getHiddenPhenomenaPhenomenonParserRuleCall_3_1_4_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Node_CommaKeyword_3_1_4_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




// "}"
protected class Node_RightCurlyBracketKeyword_3_2 extends KeywordToken  {
	
	public Node_RightCurlyBracketKeyword_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getRightCurlyBracketKeyword_3_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Alternatives_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Node ****************/


/************ begin Rule Phenomenon ****************
 *
 * Phenomenon:
 *   type=PhenomenonType? name=ID (":" description=STRING)?;
 *
 **/

// type=PhenomenonType? name=ID (":" description=STRING)?
protected class Phenomenon_Group extends GroupToken {
	
	public Phenomenon_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getPhenomenonAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Phenomenon_Group_2(parent, this, 0, inst);
			case 1: return new Phenomenon_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPhenomenonRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type=PhenomenonType?
protected class Phenomenon_TypeAssignment_0 extends AssignmentToken  {
	
	public Phenomenon_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getPhenomenonAccess().getTypeAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getPhenomenonAccess().getTypePhenomenonTypeEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// name=ID
protected class Phenomenon_NameAssignment_1 extends AssignmentToken  {
	
	public Phenomenon_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getPhenomenonAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Phenomenon_TypeAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getPhenomenonAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// (":" description=STRING)?
protected class Phenomenon_Group_2 extends GroupToken {
	
	public Phenomenon_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getPhenomenonAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Phenomenon_DescriptionAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Phenomenon_ColonKeyword_2_0 extends KeywordToken  {
	
	public Phenomenon_ColonKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPhenomenonAccess().getColonKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Phenomenon_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// description=STRING
protected class Phenomenon_DescriptionAssignment_2_1 extends AssignmentToken  {
	
	public Phenomenon_DescriptionAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getPhenomenonAccess().getDescriptionAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Phenomenon_ColonKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("description",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("description");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getPhenomenonAccess().getDescriptionSTRINGTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Phenomenon ****************/


/************ begin Rule Link ****************
 *
 * Link:
 *   from=[Node] type=LinkType to=[Node] ("{" phenomena+=Phenomenon ("," phenomena+=
 *   Phenomenon)* "}")? (":" description=STRING)?;
 *
 **/

// from=[Node] type=LinkType to=[Node] ("{" phenomena+=Phenomenon ("," phenomena+=
// Phenomenon)* "}")? (":" description=STRING)?
protected class Link_Group extends GroupToken {
	
	public Link_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getLinkAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_Group_4(parent, this, 0, inst);
			case 1: return new Link_Group_3(parent, this, 1, inst);
			case 2: return new Link_ToAssignment_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLinkRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// from=[Node]
protected class Link_FromAssignment_0 extends AssignmentToken  {
	
	public Link_FromAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLinkAccess().getFromAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("from",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("from");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLinkAccess().getFromNodeCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getLinkAccess().getFromNodeCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// type=LinkType
protected class Link_TypeAssignment_1 extends AssignmentToken  {
	
	public Link_TypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLinkAccess().getTypeAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_FromAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getLinkAccess().getTypeLinkTypeEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// to=[Node]
protected class Link_ToAssignment_2 extends AssignmentToken  {
	
	public Link_ToAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLinkAccess().getToAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_TypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("to",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("to");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLinkAccess().getToNodeCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getLinkAccess().getToNodeCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("{" phenomena+=Phenomenon ("," phenomena+=Phenomenon)* "}")?
protected class Link_Group_3 extends GroupToken {
	
	public Link_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getLinkAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_RightCurlyBracketKeyword_3_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class Link_LeftCurlyBracketKeyword_3_0 extends KeywordToken  {
	
	public Link_LeftCurlyBracketKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getLinkAccess().getLeftCurlyBracketKeyword_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_ToAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// phenomena+=Phenomenon
protected class Link_PhenomenaAssignment_3_1 extends AssignmentToken  {
	
	public Link_PhenomenaAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLinkAccess().getPhenomenaAssignment_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Phenomenon_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("phenomena",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("phenomena");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPhenomenonRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLinkAccess().getPhenomenaPhenomenonParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Link_LeftCurlyBracketKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," phenomena+=Phenomenon)*
protected class Link_Group_3_2 extends GroupToken {
	
	public Link_Group_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getLinkAccess().getGroup_3_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_PhenomenaAssignment_3_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Link_CommaKeyword_3_2_0 extends KeywordToken  {
	
	public Link_CommaKeyword_3_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getLinkAccess().getCommaKeyword_3_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_Group_3_2(parent, this, 0, inst);
			case 1: return new Link_PhenomenaAssignment_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// phenomena+=Phenomenon
protected class Link_PhenomenaAssignment_3_2_1 extends AssignmentToken  {
	
	public Link_PhenomenaAssignment_3_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLinkAccess().getPhenomenaAssignment_3_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Phenomenon_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("phenomena",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("phenomena");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPhenomenonRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLinkAccess().getPhenomenaPhenomenonParserRuleCall_3_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Link_CommaKeyword_3_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class Link_RightCurlyBracketKeyword_3_3 extends KeywordToken  {
	
	public Link_RightCurlyBracketKeyword_3_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getLinkAccess().getRightCurlyBracketKeyword_3_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_Group_3_2(parent, this, 0, inst);
			case 1: return new Link_PhenomenaAssignment_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// (":" description=STRING)?
protected class Link_Group_4 extends GroupToken {
	
	public Link_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getLinkAccess().getGroup_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_DescriptionAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Link_ColonKeyword_4_0 extends KeywordToken  {
	
	public Link_ColonKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getLinkAccess().getColonKeyword_4_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_Group_3(parent, this, 0, inst);
			case 1: return new Link_ToAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// description=STRING
protected class Link_DescriptionAssignment_4_1 extends AssignmentToken  {
	
	public Link_DescriptionAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLinkAccess().getDescriptionAssignment_4_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Link_ColonKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("description",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("description");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getLinkAccess().getDescriptionSTRINGTerminalRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Link ****************/


/************ begin Rule Model ****************
 *
 * Model:
 *   "istar" name=ID? ":" (containers+=Container|intentions+=Intention|decompositions+=
 *   Decomposition|dependencies+=Dependency|contributions+=Contribution|associations
 *   +=Association)*;
 *
 **/

// "istar" name=ID? ":" (containers+=Container|intentions+=Intention|decompositions+=
// Decomposition|dependencies+=Dependency|contributions+=Contribution|associations
// +=Association)*
protected class Model_Group extends GroupToken {
	
	public Model_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Alternatives_3(parent, this, 0, inst);
			case 1: return new Model_ColonKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "istar"
protected class Model_IstarKeyword_0 extends KeywordToken  {
	
	public Model_IstarKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getIstarKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID?
protected class Model_NameAssignment_1 extends AssignmentToken  {
	
	public Model_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_IstarKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getModelAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ":"
protected class Model_ColonKeyword_2 extends KeywordToken  {
	
	public Model_ColonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getColonKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_NameAssignment_1(parent, this, 0, inst);
			case 1: return new Model_IstarKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// (containers+=Container|intentions+=Intention|decompositions+=Decomposition|
// dependencies+=Dependency|contributions+=Contribution|associations+=Association)*
protected class Model_Alternatives_3 extends AlternativesToken {

	public Model_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getModelAccess().getAlternatives_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_ContainersAssignment_3_0(parent, this, 0, inst);
			case 1: return new Model_IntentionsAssignment_3_1(parent, this, 1, inst);
			case 2: return new Model_DecompositionsAssignment_3_2(parent, this, 2, inst);
			case 3: return new Model_DependenciesAssignment_3_3(parent, this, 3, inst);
			case 4: return new Model_ContributionsAssignment_3_4(parent, this, 4, inst);
			case 5: return new Model_AssociationsAssignment_3_5(parent, this, 5, inst);
			default: return null;
		}	
	}	
		
}

// containers+=Container
protected class Model_ContainersAssignment_3_0 extends AssignmentToken  {
	
	public Model_ContainersAssignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getContainersAssignment_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Container_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("containers",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("containers");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getContainerRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getContainersContainerParserRuleCall_3_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new Model_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// intentions+=Intention
protected class Model_IntentionsAssignment_3_1 extends AssignmentToken  {
	
	public Model_IntentionsAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getIntentionsAssignment_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Intention_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("intentions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("intentions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIntentionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getIntentionsIntentionParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new Model_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// decompositions+=Decomposition
protected class Model_DecompositionsAssignment_3_2 extends AssignmentToken  {
	
	public Model_DecompositionsAssignment_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getDecompositionsAssignment_3_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decomposition_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("decompositions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("decompositions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDecompositionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getDecompositionsDecompositionParserRuleCall_3_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new Model_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// dependencies+=Dependency
protected class Model_DependenciesAssignment_3_3 extends AssignmentToken  {
	
	public Model_DependenciesAssignment_3_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getDependenciesAssignment_3_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Dependency_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dependencies",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dependencies");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDependencyRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getDependenciesDependencyParserRuleCall_3_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new Model_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// contributions+=Contribution
protected class Model_ContributionsAssignment_3_4 extends AssignmentToken  {
	
	public Model_ContributionsAssignment_3_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getContributionsAssignment_3_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Contribution_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("contributions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("contributions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getContributionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getContributionsContributionParserRuleCall_3_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new Model_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// associations+=Association
protected class Model_AssociationsAssignment_3_5 extends AssignmentToken  {
	
	public Model_AssociationsAssignment_3_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getAssociationsAssignment_3_5();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Association_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("associations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("associations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssociationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getAssociationsAssociationParserRuleCall_3_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new Model_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Model ****************/


/************ begin Rule Container ****************
 *
 * Container:
 *   Actor|Agent|Role|Position;
 *
 **/

// Actor|Agent|Role|Position
protected class Container_Alternatives extends AlternativesToken {

	public Container_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getContainerAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Container_ActorParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Container_AgentParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Container_RoleParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Container_PositionParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getContainerRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Actor
protected class Container_ActorParserRuleCall_0 extends RuleCallToken {
	
	public Container_ActorParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContainerAccess().getActorParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Actor_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Actor_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getActorRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Agent
protected class Container_AgentParserRuleCall_1 extends RuleCallToken {
	
	public Container_AgentParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContainerAccess().getAgentParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Agent_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Agent_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAgentRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Role
protected class Container_RoleParserRuleCall_2 extends RuleCallToken {
	
	public Container_RoleParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContainerAccess().getRoleParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Role_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Role_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRoleRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Position
protected class Container_PositionParserRuleCall_3 extends RuleCallToken {
	
	public Container_PositionParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContainerAccess().getPositionParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Position_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Position_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPositionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Container ****************/


/************ begin Rule Actor ****************
 *
 * Actor:
 *   "actor" name=ID (is_a+=[Actor]|is_part_of+=[Actor])* ("{" intentions+=Intention* "}")
 *   ?;
 *
 **/

// "actor" name=ID (is_a+=[Actor]|is_part_of+=[Actor])* ("{" intentions+=Intention* "}")
// ?
protected class Actor_Group extends GroupToken {
	
	public Actor_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getActorAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Actor_Group_3(parent, this, 0, inst);
			case 1: return new Actor_Alternatives_2(parent, this, 1, inst);
			case 2: return new Actor_NameAssignment_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getActorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "actor"
protected class Actor_ActorKeyword_0 extends KeywordToken  {
	
	public Actor_ActorKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActorAccess().getActorKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Actor_NameAssignment_1 extends AssignmentToken  {
	
	public Actor_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActorAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Actor_ActorKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getActorAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// (is_a+=[Actor]|is_part_of+=[Actor])*
protected class Actor_Alternatives_2 extends AlternativesToken {

	public Actor_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getActorAccess().getAlternatives_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Actor_Is_aAssignment_2_0(parent, this, 0, inst);
			case 1: return new Actor_Is_part_ofAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// is_a+=[Actor]
protected class Actor_Is_aAssignment_2_0 extends AssignmentToken  {
	
	public Actor_Is_aAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActorAccess().getIs_aAssignment_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Actor_Alternatives_2(parent, this, 0, inst);
			case 1: return new Actor_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("is_a",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("is_a");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getActorAccess().getIs_aActorCrossReference_2_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getActorAccess().getIs_aActorCrossReference_2_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// is_part_of+=[Actor]
protected class Actor_Is_part_ofAssignment_2_1 extends AssignmentToken  {
	
	public Actor_Is_part_ofAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActorAccess().getIs_part_ofAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Actor_Alternatives_2(parent, this, 0, inst);
			case 1: return new Actor_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("is_part_of",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("is_part_of");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getActorAccess().getIs_part_ofActorCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getActorAccess().getIs_part_ofActorCrossReference_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}


// ("{" intentions+=Intention* "}")?
protected class Actor_Group_3 extends GroupToken {
	
	public Actor_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getActorAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Actor_RightCurlyBracketKeyword_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class Actor_LeftCurlyBracketKeyword_3_0 extends KeywordToken  {
	
	public Actor_LeftCurlyBracketKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActorAccess().getLeftCurlyBracketKeyword_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Actor_Alternatives_2(parent, this, 0, inst);
			case 1: return new Actor_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// intentions+=Intention*
protected class Actor_IntentionsAssignment_3_1 extends AssignmentToken  {
	
	public Actor_IntentionsAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActorAccess().getIntentionsAssignment_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Intention_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("intentions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("intentions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIntentionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActorAccess().getIntentionsIntentionParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Actor_IntentionsAssignment_3_1(parent, next, actIndex, consumed);
			case 1: return new Actor_LeftCurlyBracketKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Actor_RightCurlyBracketKeyword_3_2 extends KeywordToken  {
	
	public Actor_RightCurlyBracketKeyword_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActorAccess().getRightCurlyBracketKeyword_3_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Actor_IntentionsAssignment_3_1(parent, this, 0, inst);
			case 1: return new Actor_LeftCurlyBracketKeyword_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Actor ****************/


/************ begin Rule Agent ****************
 *
 * Agent:
 *   "agent" name=ID ("{" intentions+=Intention* "}")?;
 *
 **/

// "agent" name=ID ("{" intentions+=Intention* "}")?
protected class Agent_Group extends GroupToken {
	
	public Agent_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAgentAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Agent_Group_2(parent, this, 0, inst);
			case 1: return new Agent_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAgentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "agent"
protected class Agent_AgentKeyword_0 extends KeywordToken  {
	
	public Agent_AgentKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAgentAccess().getAgentKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Agent_NameAssignment_1 extends AssignmentToken  {
	
	public Agent_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAgentAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Agent_AgentKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAgentAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("{" intentions+=Intention* "}")?
protected class Agent_Group_2 extends GroupToken {
	
	public Agent_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAgentAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Agent_RightCurlyBracketKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class Agent_LeftCurlyBracketKeyword_2_0 extends KeywordToken  {
	
	public Agent_LeftCurlyBracketKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAgentAccess().getLeftCurlyBracketKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Agent_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// intentions+=Intention*
protected class Agent_IntentionsAssignment_2_1 extends AssignmentToken  {
	
	public Agent_IntentionsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAgentAccess().getIntentionsAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Intention_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("intentions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("intentions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIntentionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAgentAccess().getIntentionsIntentionParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Agent_IntentionsAssignment_2_1(parent, next, actIndex, consumed);
			case 1: return new Agent_LeftCurlyBracketKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Agent_RightCurlyBracketKeyword_2_2 extends KeywordToken  {
	
	public Agent_RightCurlyBracketKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAgentAccess().getRightCurlyBracketKeyword_2_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Agent_IntentionsAssignment_2_1(parent, this, 0, inst);
			case 1: return new Agent_LeftCurlyBracketKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Agent ****************/


/************ begin Rule Role ****************
 *
 * Role:
 *   "role" name=ID ("{" intentions+=Intention* "}")?;
 *
 **/

// "role" name=ID ("{" intentions+=Intention* "}")?
protected class Role_Group extends GroupToken {
	
	public Role_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getRoleAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Role_Group_2(parent, this, 0, inst);
			case 1: return new Role_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRoleRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "role"
protected class Role_RoleKeyword_0 extends KeywordToken  {
	
	public Role_RoleKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getRoleAccess().getRoleKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Role_NameAssignment_1 extends AssignmentToken  {
	
	public Role_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRoleAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Role_RoleKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getRoleAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("{" intentions+=Intention* "}")?
protected class Role_Group_2 extends GroupToken {
	
	public Role_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getRoleAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Role_RightCurlyBracketKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class Role_LeftCurlyBracketKeyword_2_0 extends KeywordToken  {
	
	public Role_LeftCurlyBracketKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getRoleAccess().getLeftCurlyBracketKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Role_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// intentions+=Intention*
protected class Role_IntentionsAssignment_2_1 extends AssignmentToken  {
	
	public Role_IntentionsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRoleAccess().getIntentionsAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Intention_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("intentions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("intentions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIntentionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRoleAccess().getIntentionsIntentionParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Role_IntentionsAssignment_2_1(parent, next, actIndex, consumed);
			case 1: return new Role_LeftCurlyBracketKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Role_RightCurlyBracketKeyword_2_2 extends KeywordToken  {
	
	public Role_RightCurlyBracketKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getRoleAccess().getRightCurlyBracketKeyword_2_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Role_IntentionsAssignment_2_1(parent, this, 0, inst);
			case 1: return new Role_LeftCurlyBracketKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Role ****************/


/************ begin Rule Position ****************
 *
 * Position:
 *   "position" name=ID ("{" intentions+=Intention* "}")?;
 *
 **/

// "position" name=ID ("{" intentions+=Intention* "}")?
protected class Position_Group extends GroupToken {
	
	public Position_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getPositionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Position_Group_2(parent, this, 0, inst);
			case 1: return new Position_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPositionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "position"
protected class Position_PositionKeyword_0 extends KeywordToken  {
	
	public Position_PositionKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPositionAccess().getPositionKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Position_NameAssignment_1 extends AssignmentToken  {
	
	public Position_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getPositionAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Position_PositionKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getPositionAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("{" intentions+=Intention* "}")?
protected class Position_Group_2 extends GroupToken {
	
	public Position_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getPositionAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Position_RightCurlyBracketKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class Position_LeftCurlyBracketKeyword_2_0 extends KeywordToken  {
	
	public Position_LeftCurlyBracketKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPositionAccess().getLeftCurlyBracketKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Position_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// intentions+=Intention*
protected class Position_IntentionsAssignment_2_1 extends AssignmentToken  {
	
	public Position_IntentionsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getPositionAccess().getIntentionsAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Intention_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("intentions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("intentions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIntentionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPositionAccess().getIntentionsIntentionParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Position_IntentionsAssignment_2_1(parent, next, actIndex, consumed);
			case 1: return new Position_LeftCurlyBracketKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Position_RightCurlyBracketKeyword_2_2 extends KeywordToken  {
	
	public Position_RightCurlyBracketKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPositionAccess().getRightCurlyBracketKeyword_2_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Position_IntentionsAssignment_2_1(parent, this, 0, inst);
			case 1: return new Position_LeftCurlyBracketKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Position ****************/


/************ begin Rule Intention ****************
 *
 * Intention:
 *   Goal|Softgoal|Task|Resource|Belief;
 *
 **/

// Goal|Softgoal|Task|Resource|Belief
protected class Intention_Alternatives extends AlternativesToken {

	public Intention_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getIntentionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Intention_GoalParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Intention_SoftgoalParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Intention_TaskParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Intention_ResourceParserRuleCall_3(parent, this, 3, inst);
			case 4: return new Intention_BeliefParserRuleCall_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIntentionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Goal
protected class Intention_GoalParserRuleCall_0 extends RuleCallToken {
	
	public Intention_GoalParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getIntentionAccess().getGoalParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Goal_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Goal_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getGoalRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Softgoal
protected class Intention_SoftgoalParserRuleCall_1 extends RuleCallToken {
	
	public Intention_SoftgoalParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getIntentionAccess().getSoftgoalParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Softgoal_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Softgoal_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSoftgoalRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Task
protected class Intention_TaskParserRuleCall_2 extends RuleCallToken {
	
	public Intention_TaskParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getIntentionAccess().getTaskParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Task_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Task_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTaskRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Resource
protected class Intention_ResourceParserRuleCall_3 extends RuleCallToken {
	
	public Intention_ResourceParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getIntentionAccess().getResourceParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Resource_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Resource_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getResourceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Belief
protected class Intention_BeliefParserRuleCall_4 extends RuleCallToken {
	
	public Intention_BeliefParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getIntentionAccess().getBeliefParserRuleCall_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Belief_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Belief_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBeliefRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Intention ****************/


/************ begin Rule Goal ****************
 *
 * Goal:
 *   "goal" name=ID ("{" decompositions+=[Decomposition]* "}")?;
 *
 **/

// "goal" name=ID ("{" decompositions+=[Decomposition]* "}")?
protected class Goal_Group extends GroupToken {
	
	public Goal_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getGoalAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Goal_Group_2(parent, this, 0, inst);
			case 1: return new Goal_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getGoalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "goal"
protected class Goal_GoalKeyword_0 extends KeywordToken  {
	
	public Goal_GoalKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGoalAccess().getGoalKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Goal_NameAssignment_1 extends AssignmentToken  {
	
	public Goal_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getGoalAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Goal_GoalKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getGoalAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("{" decompositions+=[Decomposition]* "}")?
protected class Goal_Group_2 extends GroupToken {
	
	public Goal_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getGoalAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Goal_RightCurlyBracketKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class Goal_LeftCurlyBracketKeyword_2_0 extends KeywordToken  {
	
	public Goal_LeftCurlyBracketKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGoalAccess().getLeftCurlyBracketKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Goal_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// decompositions+=[Decomposition]*
protected class Goal_DecompositionsAssignment_2_1 extends AssignmentToken  {
	
	public Goal_DecompositionsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getGoalAccess().getDecompositionsAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Goal_DecompositionsAssignment_2_1(parent, this, 0, inst);
			case 1: return new Goal_LeftCurlyBracketKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("decompositions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("decompositions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGoalAccess().getDecompositionsDecompositionCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGoalAccess().getDecompositionsDecompositionCrossReference_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "}"
protected class Goal_RightCurlyBracketKeyword_2_2 extends KeywordToken  {
	
	public Goal_RightCurlyBracketKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGoalAccess().getRightCurlyBracketKeyword_2_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Goal_DecompositionsAssignment_2_1(parent, this, 0, inst);
			case 1: return new Goal_LeftCurlyBracketKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Goal ****************/


/************ begin Rule Softgoal ****************
 *
 * Softgoal:
 *   "soft" name=ID;
 *
 **/

// "soft" name=ID
protected class Softgoal_Group extends GroupToken {
	
	public Softgoal_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSoftgoalAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Softgoal_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSoftgoalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "soft"
protected class Softgoal_SoftKeyword_0 extends KeywordToken  {
	
	public Softgoal_SoftKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSoftgoalAccess().getSoftKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Softgoal_NameAssignment_1 extends AssignmentToken  {
	
	public Softgoal_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSoftgoalAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Softgoal_SoftKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSoftgoalAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Softgoal ****************/


/************ begin Rule Task ****************
 *
 * Task:
 *   "task" name=ID;
 *
 **/

// "task" name=ID
protected class Task_Group extends GroupToken {
	
	public Task_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTaskAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Task_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTaskRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "task"
protected class Task_TaskKeyword_0 extends KeywordToken  {
	
	public Task_TaskKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTaskAccess().getTaskKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Task_NameAssignment_1 extends AssignmentToken  {
	
	public Task_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTaskAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Task_TaskKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTaskAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Task ****************/


/************ begin Rule Resource ****************
 *
 * Resource:
 *   "resource" name=ID;
 *
 **/

// "resource" name=ID
protected class Resource_Group extends GroupToken {
	
	public Resource_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getResourceAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Resource_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getResourceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "resource"
protected class Resource_ResourceKeyword_0 extends KeywordToken  {
	
	public Resource_ResourceKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getResourceAccess().getResourceKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Resource_NameAssignment_1 extends AssignmentToken  {
	
	public Resource_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getResourceAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Resource_ResourceKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getResourceAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Resource ****************/


/************ begin Rule Belief ****************
 *
 * Belief:
 *   "belief" name=ID;
 *
 **/

// "belief" name=ID
protected class Belief_Group extends GroupToken {
	
	public Belief_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBeliefAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Belief_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBeliefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "belief"
protected class Belief_BeliefKeyword_0 extends KeywordToken  {
	
	public Belief_BeliefKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBeliefAccess().getBeliefKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Belief_NameAssignment_1 extends AssignmentToken  {
	
	public Belief_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBeliefAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Belief_BeliefKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBeliefAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Belief ****************/


/************ begin Rule Dependable ****************
 *
 * Dependable:
 *   Intention|Container;
 *
 **/

// Intention|Container
protected class Dependable_Alternatives extends AlternativesToken {

	public Dependable_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getDependableAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Dependable_IntentionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Dependable_ContainerParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDependableRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Intention
protected class Dependable_IntentionParserRuleCall_0 extends RuleCallToken {
	
	public Dependable_IntentionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getDependableAccess().getIntentionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Intention_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Intention_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntentionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Container
protected class Dependable_ContainerParserRuleCall_1 extends RuleCallToken {
	
	public Dependable_ContainerParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getDependableAccess().getContainerParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Container_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Container_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getContainerRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Dependable ****************/


/************ begin Rule Association ****************
 *
 * Association:
 *   source=[Container] "~~>" target=[Container];
 *
 **/

// source=[Container] "~~>" target=[Container]
protected class Association_Group extends GroupToken {
	
	public Association_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAssociationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Association_TargetAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssociationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// source=[Container]
protected class Association_SourceAssignment_0 extends AssignmentToken  {
	
	public Association_SourceAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssociationAccess().getSourceAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssociationAccess().getSourceContainerCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAssociationAccess().getSourceContainerCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "~~>"
protected class Association_TildeTildeGreaterThanSignKeyword_1 extends KeywordToken  {
	
	public Association_TildeTildeGreaterThanSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssociationAccess().getTildeTildeGreaterThanSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Association_SourceAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// target=[Container]
protected class Association_TargetAssignment_2 extends AssignmentToken  {
	
	public Association_TargetAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssociationAccess().getTargetAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Association_TildeTildeGreaterThanSignKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssociationAccess().getTargetContainerCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAssociationAccess().getTargetContainerCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule Association ****************/


/************ begin Rule Dependency ****************
 *
 * Dependency:
 *   dependencyFrom=[Dependable] "~>" dependencyTo=[Dependable];
 *
 **/

// dependencyFrom=[Dependable] "~>" dependencyTo=[Dependable]
protected class Dependency_Group extends GroupToken {
	
	public Dependency_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getDependencyAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Dependency_DependencyToAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDependencyRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// dependencyFrom=[Dependable]
protected class Dependency_DependencyFromAssignment_0 extends AssignmentToken  {
	
	public Dependency_DependencyFromAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDependencyAccess().getDependencyFromAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dependencyFrom",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dependencyFrom");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDependencyAccess().getDependencyFromDependableCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getDependencyAccess().getDependencyFromDependableCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "~>"
protected class Dependency_TildeGreaterThanSignKeyword_1 extends KeywordToken  {
	
	public Dependency_TildeGreaterThanSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getDependencyAccess().getTildeGreaterThanSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Dependency_DependencyFromAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// dependencyTo=[Dependable]
protected class Dependency_DependencyToAssignment_2 extends AssignmentToken  {
	
	public Dependency_DependencyToAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDependencyAccess().getDependencyToAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Dependency_TildeGreaterThanSignKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dependencyTo",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dependencyTo");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDependencyAccess().getDependencyToDependableCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getDependencyAccess().getDependencyToDependableCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule Dependency ****************/


/************ begin Rule Decomposition ****************
 *
 * Decomposition:
 *   AndDecomposition|OrDecomposition;
 *
 **/

// AndDecomposition|OrDecomposition
protected class Decomposition_Alternatives extends AlternativesToken {

	public Decomposition_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getDecompositionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decomposition_AndDecompositionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Decomposition_OrDecompositionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDecompositionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndDecomposition
protected class Decomposition_AndDecompositionParserRuleCall_0 extends RuleCallToken {
	
	public Decomposition_AndDecompositionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getDecompositionAccess().getAndDecompositionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndDecomposition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndDecomposition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndDecompositionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// OrDecomposition
protected class Decomposition_OrDecompositionParserRuleCall_1 extends RuleCallToken {
	
	public Decomposition_OrDecompositionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getDecompositionAccess().getOrDecompositionParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrDecomposition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrDecomposition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrDecompositionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Decomposition ****************/


/************ begin Rule AndDecomposition ****************
 *
 * AndDecomposition:
 *   target=[Intention] "<-(and)-" source=[Intention];
 *
 **/

// target=[Intention] "<-(and)-" source=[Intention]
protected class AndDecomposition_Group extends GroupToken {
	
	public AndDecomposition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndDecompositionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndDecomposition_SourceAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndDecompositionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// target=[Intention]
protected class AndDecomposition_TargetAssignment_0 extends AssignmentToken  {
	
	public AndDecomposition_TargetAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndDecompositionAccess().getTargetAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndDecompositionAccess().getTargetIntentionCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAndDecompositionAccess().getTargetIntentionCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "<-(and)-"
protected class AndDecomposition_AndKeyword_1 extends KeywordToken  {
	
	public AndDecomposition_AndKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAndDecompositionAccess().getAndKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndDecomposition_TargetAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// source=[Intention]
protected class AndDecomposition_SourceAssignment_2 extends AssignmentToken  {
	
	public AndDecomposition_SourceAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndDecompositionAccess().getSourceAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndDecomposition_AndKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndDecompositionAccess().getSourceIntentionCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAndDecompositionAccess().getSourceIntentionCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule AndDecomposition ****************/


/************ begin Rule OrDecomposition ****************
 *
 * OrDecomposition:
 *   target=[Intention] "<-(or)-" source=[Intention];
 *
 **/

// target=[Intention] "<-(or)-" source=[Intention]
protected class OrDecomposition_Group extends GroupToken {
	
	public OrDecomposition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrDecompositionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrDecomposition_SourceAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrDecompositionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// target=[Intention]
protected class OrDecomposition_TargetAssignment_0 extends AssignmentToken  {
	
	public OrDecomposition_TargetAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrDecompositionAccess().getTargetAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrDecompositionAccess().getTargetIntentionCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getOrDecompositionAccess().getTargetIntentionCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "<-(or)-"
protected class OrDecomposition_OrKeyword_1 extends KeywordToken  {
	
	public OrDecomposition_OrKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOrDecompositionAccess().getOrKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrDecomposition_TargetAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// source=[Intention]
protected class OrDecomposition_SourceAssignment_2 extends AssignmentToken  {
	
	public OrDecomposition_SourceAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrDecompositionAccess().getSourceAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrDecomposition_OrKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrDecompositionAccess().getSourceIntentionCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getOrDecompositionAccess().getSourceIntentionCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule OrDecomposition ****************/


/************ begin Rule Contribution ****************
 *
 * Contribution:
 *   AndContribution|OrContribution|HelpContribution|HurtContribution|
 *   MakeContribution|BreakContribution;
 *
 **/

// AndContribution|OrContribution|HelpContribution|HurtContribution|
// MakeContribution|BreakContribution
protected class Contribution_Alternatives extends AlternativesToken {

	public Contribution_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getContributionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Contribution_AndContributionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Contribution_OrContributionParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Contribution_HelpContributionParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Contribution_HurtContributionParserRuleCall_3(parent, this, 3, inst);
			case 4: return new Contribution_MakeContributionParserRuleCall_4(parent, this, 4, inst);
			case 5: return new Contribution_BreakContributionParserRuleCall_5(parent, this, 5, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getContributionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndContribution
protected class Contribution_AndContributionParserRuleCall_0 extends RuleCallToken {
	
	public Contribution_AndContributionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContributionAccess().getAndContributionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndContribution_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndContribution_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndContributionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// OrContribution
protected class Contribution_OrContributionParserRuleCall_1 extends RuleCallToken {
	
	public Contribution_OrContributionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContributionAccess().getOrContributionParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrContribution_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrContribution_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrContributionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// HelpContribution
protected class Contribution_HelpContributionParserRuleCall_2 extends RuleCallToken {
	
	public Contribution_HelpContributionParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContributionAccess().getHelpContributionParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HelpContribution_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(HelpContribution_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getHelpContributionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// HurtContribution
protected class Contribution_HurtContributionParserRuleCall_3 extends RuleCallToken {
	
	public Contribution_HurtContributionParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContributionAccess().getHurtContributionParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HurtContribution_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(HurtContribution_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getHurtContributionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// MakeContribution
protected class Contribution_MakeContributionParserRuleCall_4 extends RuleCallToken {
	
	public Contribution_MakeContributionParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContributionAccess().getMakeContributionParserRuleCall_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MakeContribution_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(MakeContribution_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMakeContributionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BreakContribution
protected class Contribution_BreakContributionParserRuleCall_5 extends RuleCallToken {
	
	public Contribution_BreakContributionParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getContributionAccess().getBreakContributionParserRuleCall_5();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BreakContribution_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BreakContribution_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBreakContributionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Contribution ****************/


/************ begin Rule AndContribution ****************
 *
 * AndContribution:
 *   source=[Intention] "-(and)->" target=[Intention];
 *
 **/

// source=[Intention] "-(and)->" target=[Intention]
protected class AndContribution_Group extends GroupToken {
	
	public AndContribution_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndContributionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndContribution_TargetAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndContributionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// source=[Intention]
protected class AndContribution_SourceAssignment_0 extends AssignmentToken  {
	
	public AndContribution_SourceAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndContributionAccess().getSourceAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndContributionAccess().getSourceIntentionCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAndContributionAccess().getSourceIntentionCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "-(and)->"
protected class AndContribution_AndKeyword_1 extends KeywordToken  {
	
	public AndContribution_AndKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAndContributionAccess().getAndKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndContribution_SourceAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// target=[Intention]
protected class AndContribution_TargetAssignment_2 extends AssignmentToken  {
	
	public AndContribution_TargetAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndContributionAccess().getTargetAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndContribution_AndKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndContributionAccess().getTargetIntentionCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAndContributionAccess().getTargetIntentionCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule AndContribution ****************/


/************ begin Rule OrContribution ****************
 *
 * OrContribution:
 *   source=[Intention] "-(or)->" target=[Intention];
 *
 **/

// source=[Intention] "-(or)->" target=[Intention]
protected class OrContribution_Group extends GroupToken {
	
	public OrContribution_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrContributionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrContribution_TargetAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrContributionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// source=[Intention]
protected class OrContribution_SourceAssignment_0 extends AssignmentToken  {
	
	public OrContribution_SourceAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrContributionAccess().getSourceAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrContributionAccess().getSourceIntentionCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getOrContributionAccess().getSourceIntentionCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "-(or)->"
protected class OrContribution_OrKeyword_1 extends KeywordToken  {
	
	public OrContribution_OrKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOrContributionAccess().getOrKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrContribution_SourceAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// target=[Intention]
protected class OrContribution_TargetAssignment_2 extends AssignmentToken  {
	
	public OrContribution_TargetAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrContributionAccess().getTargetAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrContribution_OrKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrContributionAccess().getTargetIntentionCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getOrContributionAccess().getTargetIntentionCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule OrContribution ****************/


/************ begin Rule HelpContribution ****************
 *
 * HelpContribution:
 *   source=[Intention] "-(+)->" target=[Intention];
 *
 **/

// source=[Intention] "-(+)->" target=[Intention]
protected class HelpContribution_Group extends GroupToken {
	
	public HelpContribution_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getHelpContributionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HelpContribution_TargetAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getHelpContributionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// source=[Intention]
protected class HelpContribution_SourceAssignment_0 extends AssignmentToken  {
	
	public HelpContribution_SourceAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getHelpContributionAccess().getSourceAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getHelpContributionAccess().getSourceIntentionCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getHelpContributionAccess().getSourceIntentionCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "-(+)->"
protected class HelpContribution_HyphenMinusLeftParenthesisPlusSignRightParenthesisHyphenMinusGreaterThanSignKeyword_1 extends KeywordToken  {
	
	public HelpContribution_HyphenMinusLeftParenthesisPlusSignRightParenthesisHyphenMinusGreaterThanSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getHelpContributionAccess().getHyphenMinusLeftParenthesisPlusSignRightParenthesisHyphenMinusGreaterThanSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HelpContribution_SourceAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// target=[Intention]
protected class HelpContribution_TargetAssignment_2 extends AssignmentToken  {
	
	public HelpContribution_TargetAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getHelpContributionAccess().getTargetAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HelpContribution_HyphenMinusLeftParenthesisPlusSignRightParenthesisHyphenMinusGreaterThanSignKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getHelpContributionAccess().getTargetIntentionCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getHelpContributionAccess().getTargetIntentionCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule HelpContribution ****************/


/************ begin Rule MakeContribution ****************
 *
 * MakeContribution:
 *   source=[Intention] "-(++)->" target=[Intention];
 *
 **/

// source=[Intention] "-(++)->" target=[Intention]
protected class MakeContribution_Group extends GroupToken {
	
	public MakeContribution_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMakeContributionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MakeContribution_TargetAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMakeContributionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// source=[Intention]
protected class MakeContribution_SourceAssignment_0 extends AssignmentToken  {
	
	public MakeContribution_SourceAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMakeContributionAccess().getSourceAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMakeContributionAccess().getSourceIntentionCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getMakeContributionAccess().getSourceIntentionCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "-(++)->"
protected class MakeContribution_HyphenMinusLeftParenthesisPlusSignPlusSignRightParenthesisHyphenMinusGreaterThanSignKeyword_1 extends KeywordToken  {
	
	public MakeContribution_HyphenMinusLeftParenthesisPlusSignPlusSignRightParenthesisHyphenMinusGreaterThanSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMakeContributionAccess().getHyphenMinusLeftParenthesisPlusSignPlusSignRightParenthesisHyphenMinusGreaterThanSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MakeContribution_SourceAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// target=[Intention]
protected class MakeContribution_TargetAssignment_2 extends AssignmentToken  {
	
	public MakeContribution_TargetAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMakeContributionAccess().getTargetAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MakeContribution_HyphenMinusLeftParenthesisPlusSignPlusSignRightParenthesisHyphenMinusGreaterThanSignKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMakeContributionAccess().getTargetIntentionCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getMakeContributionAccess().getTargetIntentionCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule MakeContribution ****************/


/************ begin Rule HurtContribution ****************
 *
 * HurtContribution:
 *   source=[Intention] "-(-)->" target=[Intention];
 *
 **/

// source=[Intention] "-(-)->" target=[Intention]
protected class HurtContribution_Group extends GroupToken {
	
	public HurtContribution_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getHurtContributionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HurtContribution_TargetAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getHurtContributionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// source=[Intention]
protected class HurtContribution_SourceAssignment_0 extends AssignmentToken  {
	
	public HurtContribution_SourceAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getHurtContributionAccess().getSourceAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getHurtContributionAccess().getSourceIntentionCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getHurtContributionAccess().getSourceIntentionCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "-(-)->"
protected class HurtContribution_HyphenMinusLeftParenthesisHyphenMinusRightParenthesisHyphenMinusGreaterThanSignKeyword_1 extends KeywordToken  {
	
	public HurtContribution_HyphenMinusLeftParenthesisHyphenMinusRightParenthesisHyphenMinusGreaterThanSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getHurtContributionAccess().getHyphenMinusLeftParenthesisHyphenMinusRightParenthesisHyphenMinusGreaterThanSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HurtContribution_SourceAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// target=[Intention]
protected class HurtContribution_TargetAssignment_2 extends AssignmentToken  {
	
	public HurtContribution_TargetAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getHurtContributionAccess().getTargetAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HurtContribution_HyphenMinusLeftParenthesisHyphenMinusRightParenthesisHyphenMinusGreaterThanSignKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getHurtContributionAccess().getTargetIntentionCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getHurtContributionAccess().getTargetIntentionCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule HurtContribution ****************/


/************ begin Rule BreakContribution ****************
 *
 * BreakContribution:
 *   source=[Intention] "-(--)->" target=[Intention];
 *
 **/

// source=[Intention] "-(--)->" target=[Intention]
protected class BreakContribution_Group extends GroupToken {
	
	public BreakContribution_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBreakContributionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BreakContribution_TargetAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBreakContributionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// source=[Intention]
protected class BreakContribution_SourceAssignment_0 extends AssignmentToken  {
	
	public BreakContribution_SourceAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBreakContributionAccess().getSourceAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBreakContributionAccess().getSourceIntentionCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getBreakContributionAccess().getSourceIntentionCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "-(--)->"
protected class BreakContribution_HyphenMinusLeftParenthesisHyphenMinusHyphenMinusRightParenthesisHyphenMinusGreaterThanSignKeyword_1 extends KeywordToken  {
	
	public BreakContribution_HyphenMinusLeftParenthesisHyphenMinusHyphenMinusRightParenthesisHyphenMinusGreaterThanSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBreakContributionAccess().getHyphenMinusLeftParenthesisHyphenMinusHyphenMinusRightParenthesisHyphenMinusGreaterThanSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BreakContribution_SourceAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// target=[Intention]
protected class BreakContribution_TargetAssignment_2 extends AssignmentToken  {
	
	public BreakContribution_TargetAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBreakContributionAccess().getTargetAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BreakContribution_HyphenMinusLeftParenthesisHyphenMinusHyphenMinusRightParenthesisHyphenMinusGreaterThanSignKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBreakContributionAccess().getTargetIntentionCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getBreakContributionAccess().getTargetIntentionCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule BreakContribution ****************/

}
