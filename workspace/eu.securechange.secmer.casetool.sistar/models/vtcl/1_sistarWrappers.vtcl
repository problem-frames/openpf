namespace secmer.sistar;
import nemf.packages.tropos;

machine wrap
{

	pattern model(TroposModel) = {
		Diagram(TroposModel);
	}
	 
// HELPERS	
//	pattern actorWantsAssetProtected(Actor, SecurityGoal, Asset) = {
//		find actorWantsGoal(Actor, SecurityGoal);
//		find securityGoal(SecurityGoal);
//		find protect(SecurityGoal, Asset);
//		find asset(Asset); 
//		find actorProvidesResource(Actor, Asset); // TODO remove this? what if someone else provides it?
//	}
	pattern actorActsToFulfillGoal(Actor, Action, Goal) = {
		find carryOut(Actor, Action);
		find fulfill(Action, Goal);
	}
 
  	pattern carryOut(Actor, Process) = {
 	 	find carryOutDirect(Actor, Process);
 	} or {
 		find carryOut(Actor, SuperProcess);
 	 	find decomposeDirect(SuperProcess, Process);	 	
 	}
 		 
 	pattern actorWantsGoal(Actor, Goal) = {
 	 	find actorWantsGoalDirect(Actor, Goal);
 	} or {
 		find actorWantsGoal(Actor, GParent);
 		find decomposeDirect(GParent, Goal);
 		// ignore composition type
 	}
 	
 	pattern doDelegation(Act1, Act2/*, Dependum*/) = {
 		find doDelegationDirect(Act1, Act2/*, Dependum*/);
// 	} or {
// 		find doDelegation(Act1, Act2, SuperDependum);
// 		find decomposeDirect(SuperDependum, Dependum);
 	}
 	pattern canDelegation(Act1, Act2/*, Dependum*/) = {
 		find canDelegationDirect(Act1, Act2/*, Dependum*/);
 //	} or {
 //		find canDelegation(Act1, Act2, SuperDependum);
 //		find decomposeDirect(SuperDependum, Dependum);
 	}
 	pattern trust(Act1, Act2/*, Dependum*/) = {
 		find trustDirect(Act1, Act2/*, Dependum*/);
 //	} or {
 //		find trust(Act1, Act2, SuperDependum);
 //		find decomposeDirect(SuperDependum, Dependum);
 	}
 	
// SYNTAX LEVEL, SISTAR WRAPPERS

 	pattern objectName(GraphicalObject, Name) = {
 		GraphicalObject(GraphicalObject);
 		GraphicalObject.name(GN, GraphicalObject, Name);
 		nemf.ecore.datatypes.EString(Name);
 	}
 	
 	shareable pattern goalReplica(G1, G2) = { // stupid Sistar...
		find goalName(G1, Name);
 	 	find goalName(G2, Name);
		//check(name(G1) == name(G2)); // stupid Sistar...
 	}	
 	pattern goalName(Goal, Name) = {
		find goal(Goal);
		find objectName(Goal, Name); 		
 	}
 		
 	
 	pattern decomposeDirectWithType(Parent, Child, CompositionType) = {
   	 	find troposRelation(Composition, Parent, Child);
  	 	Composition(Composition);
  	 	Composition.compositionType(CT, Composition, CompositionType);  
 		ECompositionType(CompositionType);		
 	}
  	pattern decomposeDirect(Parent, Child) = {
   	 	find decomposeDirectWithType(Parent, Child, CompositionType);
 	}
  	pattern decomposeDirectAND(Parent, Child) = {
   	 	find decomposeDirectWithType(Parent, Child, CompositionType);
		check(toString(value(CompositionType)) == "AND");
 	}
  	pattern decomposeDirectOR(Parent, Child) = {
   	 	find decomposeDirectWithType(Parent, Child, CompositionType);
		check(toString(value(CompositionType)) == "OR");
 	}
 			
 	
 	/*
 	pattern decomposeGoal(ParentGoal, ChildGoal, CompositionType) = {
 	 	find goal(ParentGoal);
 	 	find goal(ChildGoal);
  	 	find decompose(ParentGoal, ChildGoal, CompositionType);
 	}
 	
 	pattern decomposeActivity(Activity, Action) = {
 		find Action(Action);
 		find activity(Activity);
 		find decompose(ParentGoal, ChildGoal, CompositionType);
 		//Composition.compositionType(CT, Rel, CompositionType);
 		//ECompositionType(CompositionType);
 		//check(toString(value(CompositionType)) == "AND");
 	} 	
 	*/
 	
 	pattern dependency(Act1, Act2, DependencyType/*, Dependum*/) = {
 	 	find actor(Act1);
 	 	find actor(Act2);
  	 	find troposRelation(Dependency, Act1, Act2);
  	 	Dependency(Dependency);
  	 	Dependency.dependencyType(DT, Dependency, DependencyType);  
 		EDependencyType(DependencyType);
 		//Dependency.dependum(DEM, Dependency, Dependum);	
 		//Service(Dependum);	
 	}
 	pattern trustDirect(Act1, Act2/*, Dependum*/) = {
		find dependency(Act1, Act2, DependencyType/*, Dependum*/);
		check(toString(value(DependencyType)) == "TRUST_EXECUTION");
	} 
 	pattern doDelegationDirect(Act1, Act2/*, Dependum*/) = {
		find dependency(Act1, Act2, DependencyType/*, Dependum*/);
		check(toString(value(DependencyType)) == "DELEGATION_EXECUTION");
	} 
 	pattern canDelegationDirect(Act1, Act2/*, Dependum*/) = {
		find dependency(Act1, Act2, DependencyType/*, Dependum*/);
		check(toString(value(DependencyType)) == "DELEGATION_PERMISSION");
	} 
 	
 	 pattern actorWantsGoalDirect(Actor, Goal) = {
 	 	find actor(Actor);
 	 	find goal(Goal);
 	 	find troposRelation(Request, Actor, Goal);  
 	 	Ownership(Request);
		Ownership.ownershipType(OT, Request, RequestType);
		EOwnershipType(RequestType);
		check(toString(value(RequestType)) == "REQUEST");
 	 }

 	
 	
	pattern actor(Actor) = {
		Actor(Actor);
	}
 	pattern actorName(Actor, Name) = {
		find actor(Actor);
		find objectName(Actor, Name); 		
 	}
	
   	//pattern activity(Activity) = {
  	//	find Action(Activity);
  	//}  	  	
  /*	pattern attacker(Act) = {
  		find actor(Act);
 	 	find hasAnnotationID(Act, AnnotationID);
 	 	check(toString(value(AnnotationID)) == "security.attacker");
  	}*/
//  	pattern asset(Asset) = {
// 	 	find hasAnnotationID(Asset, AnnotationID);
// 	 	check(toString(value(AnnotationID)) == "security.asset");
// 	}
 	pattern goal(Goal) = {
 	 	Service(Goal); 	 	
 	 	Service.serviceType(ST, Goal, GoalType); 	 	
 	 	EServiceType(GoalType);
 	 	check(toString(value(GoalType)) == "GOAL");
 	} 	
/*  	pattern antiGoal(Goal) = {
 	 	find goal(Goal);
 	 	find hasAnnotationID(Goal, AnnotationID);
 	 	check(toString(value(AnnotationID)) == "security.antiGoal");
 	} */ 	
//  	pattern securityGoal(Goal) = {
// 	 	find goal(Goal);
// 	 	find hasAnnotationID(Goal, AnnotationID);
// 	 	check(toString(value(AnnotationID)) == "security.securityGoal");
// 	} 	
//  pattern confidentialitySecurityGoal(Goal) = {
// 	 	find securityGoal(Goal);
// 	 	//find hasAnnotationID(Goal, AnnotationID);
// 	 	//check(toString(value(AnnotationID)) == "security.securityGoal.confidentiality");
// 	} 	  	
// 	pattern integritySecurityGoal(Goal) = {
// 	 	find securityGoal(Goal);
// 	 	//find hasAnnotationID(Goal, AnnotationID);
// 	 	//check(toString(value(AnnotationID)) == "security.securityGoal.integrity");
// 	} 	
 	pattern Action(Action) = {
 	 	Service(Action);
 	 	Service.serviceType(ST, Action, ActionType);
 	 	EServiceType(ActionType);
 	 	check(toString(value(ActionType)) == "TASK");
 	}
//  	pattern encryptionAction(Action) = {
// 	 	find Action(Action);
 	 	//find hasAnnotationID(Action, AnnotationID);
 	 	//check(toString(value(AnnotationID)) == "security.action.encryption");
// 	} 	
//  	pattern signatureAction(Action) = {
// 	 	find Action(Action);
 	 	//find hasAnnotationID(Action, AnnotationID);
 	 	//check(toString(value(AnnotationID)) == "security.action.signature");
// 	}  	
  	/*pattern attack(Activity) = {
 	 	find activity(Activity);
 	 	find hasAnnotationID(Activity, AnnotationID);
 	 	check(toString(value(AnnotationID)) == "security.attack");
 	}*/   	
//  	pattern protect(Goal, Asset) = {
// 	 	find securityGoal(Goal);
// 	 	find troposRelation(Rel, Goal, Asset);
// 	 	find asset(Asset);
//	 	find hasAnnotationID(Rel, AnnotationID);
// 	 	check(toString(value(AnnotationID)) == "security.protect");
// 	}  
/*  	pattern deny(AntiGoal, SecurityGoal) = {
 	 	find antiGoal(AntiGoal);
 	 	find securityGoal(SecurityGoal);
 	 	find troposRelation(Rel, AntiGoal, SecurityGoal);  	 	
	 	find hasAnnotationID(Rel, AnnotationID);
 	 	check(toString(value(AnnotationID)) == "security.deny");
 	}*/
 	pattern carryOutDirect(Actor, Action) = {
 	 	find actor(Actor);
 	 	find Action(Action);
		Actor.services(AS, Actor, Action);
		//Ownership.ownershipType(OT, Request, RequestType);
		//EOwnershipType(RequestType);
		//check(toString(value(RequestType)) == "REQUEST");
 	}  
//  	pattern carryOutDirect(Actor, Action) = {
// 	 	find actor(Actor);
// 	 	find Action(Action); 	 	
// 	 	find troposRelation(Rel, Actor, Action);  	 	
//	 	find hasAnnotationID(Rel, AnnotationID);
// 	 	check(toString(value(AnnotationID)) == "security.carryOut");
// 	}  
 	/*pattern damage(Attack, Asset) = {
 	 	find attack(Attack);
 	 	find asset(Asset); 	 	
 	 	find troposRelation(Rel, Attack, Asset);  	 	
	 	find hasAnnotationID(Rel, AnnotationID);
 	 	check(toString(value(AnnotationID)) == "security.damage");
 	} */ 
	pattern fulfill(Process, Goal) = {
		find Action(Process);
		find goal(Goal);
		find troposRelation(Rel, Process, Goal);
		MeansEnd(Rel);
	} 
	pattern actorProvidesResource(Actor, Resource) = {
		Actor(Actor);
		Actor.services(AS, Actor, Resource);
 	 	Service(Resource);
 	 	Service.serviceType(ST, Resource, ResourceType);
 	 	EServiceType(ResourceType);
 	 	check(toString(value(ResourceType)) == "RESOURCE");
		
	}	
	//or {
	//	find activity(Process);
	//	find goal(Goal);
	//	find troposRelation(Rel, Process, Goal);
	//	MeansEnd(Rel);
	//} 	
 	/*pattern exploitedBy(Vulnerability, Attack) = {
 		find vulnerability(Vulnerability);
 		find attack(Attack);
 		find troposRelation(Rel, Vulnerability, Attack);
 		find hasAnnotationID(Rel, AnnotationID);
 		check(toString(value(AnnotationID)) == "security.exploitedBy");
 	}*/
	pattern troposRelation(Rel, Src, Trg) = {
 	 	Relation(Rel); 	 	
 	 	Relation.source(RS, Rel, Src);
 	 	Relation.target(RT, Rel, Trg);
 	 	GraphicalObject(Src);
 	 	GraphicalObject(Trg);
	} 	
/*	pattern vulnerability(Vulnerability) = {
		find hasAnnotationID(Vulnerability, AnnotationID);
		check(toString(value(AnnotationID)) == "security.situation.vulnerability");
	}
	pattern threat(Threat) = {
		find hasAnnotationID(Threat, AnnotationID);
		check(toString(value(AnnotationID)) == "security.situation.threat");
	} 	*/
	/*pattern hasAnnotationID(Annotated, AnnotationID) = {
		GraphicalObject(Annotated);
		GraphicalObject.domainAnnotations(DA, Annotated, Annotation);
		DomainAnnotation(Annotation);
		DomainAnnotation.annotationID(AID, Annotation, AnnotationID);
		//datatypes.String(AnnotationID);
	}	*/
}